---
image: https://swr-card.vercel.app/
description: 'We are excited to announce SWR v2.0 release, with various improvements of DX and new features like preloading, stale, optimistic update and more.'
date:
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

import Authors, { Author } from 'components/authors'
import Video from 'components/video'

# Announcing SWR 2.0

<Authors date="August 27th, 2021">
  <Author name="Shu Ding" link="https://twitter.com/shuding_" />
  <Author name="Jiachi Liu" link="https://twitter.com/huozhi" />
  <Author name="Toru Kobayashi" link="https://twitter.com/koba04" />
  <Author name="Yixuan Xu" link="https://twitter.com/yixuanxu94" />
</Authors>

We are thrilled to introduce the SWR 2.0 release, with a lot of exciting new features and quality-of-life improvements to help you build better applications.

## Better Mutations

Mutations are a big part of the data fetching story. Previously we have a powerful `mutate` API that allows you to revalidate and update the data manually. In 2.0, we have made a few improvements and powerful additions to mutations in SWR:

### useSWRMutation

`useSWRMutation` is a new hook to make remote mutations easier in a declarative API. You can define a mutation using a hook, and trigger it later:

```jsx {11,16}
import useSWRMutation from 'swr/mutation'

async function sendRequest(url, { arg }) {
  return fetch(url, {
    method: 'POST',
    body: JSON.stringify(arg)
  })
}

function App() {
  const { trigger, isMutating } = useSWRMutation('/api/user', sendRequest)

  return (
    <button
      disabled={isMutating}
      onClick={() => trigger({ username: 'johndoe' })}
    >{
      isMutating ? 'Creating...' : 'Create User'
    }</button>
  )
}
```

In the example above, a mutation of `sendRequest` is defined and it affects the `'/api/user'` resource.
Unlike `useSWR`, the request will start immediately upon rendering. Instead, it returns a `trigger` function that can be called later to start the mutation manually.

When clicking the button, `sendRequest` will be triggered with the extra argument `{ username: 'johndoe' }`, and `isMutating` will be set to `true` until the mutation is finished.

This new hook also covers other pain points you might have for mutations:

- Show optimistic UI while mutating
- Rollback automatically when mutation fails
- Detect and avoid race conditions between `useSWR` and other mutations of the same resource
- Populate the cache of `useSWR` after mutation finishes
- ...

Detailed API references and examples can be found [here](/docs/mutation#useswrmutation) and following sections.

### Optimistic UI for Mutations

Optimistic UI is a great model to make your website feel fast and snappy, but at the same time very hard to do correct. 
SWR has some new powerful options added to make it easier.

For example, we have a normal mutation that adds a new todo to the todo list. The `await addNewTodo(...)` request
could be slow sometimes, so we want to immediately show the new item everywhere in the UI. The new `optimisticData` option does exactly that:
it updates the local SWR cache optimistically.

Then, let‚Äôs say when the request finishes, `await addNewTodo(...)` request directly returns the updated list. In that case we can
enable `populateCache` to update our data directly using that response. As it‚Äôs already from the source of the truth,
we don‚Äôt need another revalidation afterwards, hence we disabled `revalidate`.

Lastly, if `await addNewTodo(...)` fails with an exception, we can rollback with `rollbackOnError` set to `true` (which is also the default).
The `optimisticData` we previously displayed will be reverted.

```jsx
const { mutate, data } = useSWR('/api/todos')

// ...
mutate(async () => await addNewTodo('New Item'), {
  optimisticData: [...data, 'New Item'],
  populateCache: true,
  revalidate: false,
  rollbackOnError: true,
})
```

And here is a demo showing that behavior:

<Video
  src="/video/optimistic-ui.mp4"
  caption="Optimistic UI with automatic error rollback"
  ratio={2348/896}
/>

These APIs are supported in the new `useSWRMutation` hook as well. To learn more about them, you can check out our [docs](/docs/mutation#optimistic-updates).

### Mutate Multiple Keys

The global `mutate` API now accepts a filter function, where you can mutate or revalidate specific keys. This will be helpful for use cases such as invalidting all the cached data. To learn more, you can read [Mutate Multiple Keys](/docs/mutation#mutate-multiple-items) in the docs.

```jsx
import { mutate } from 'swr'
// Or from the hook if you have customized your cache provider:
// { mutate } = useSWRConfig()

// Mutate single resource
mutate(key)

// Mutate multiple resources to make them `undefined`
mutate(
  key => typeof key === 'string' && key.startsWith('/api/item?id='),
  undefined,
  { revalidate: true }
)
```

## Better User Experience

### SWR DevTools

SWRDevTools is a browser extension for SWR, which helps to debug your SWR cache and the results of your fetcher. Check our [devtools](/docs/advanced/devtools) section for how to use devtools in your application.

![](/img/devtools/cache-view.jpg)

### Preload Data

Sometimes, preloading data can improve the user experience tremendously.
If you know the resource is going to be used later in the application, you can use the new `preload` API to start fetching it early:

```jsx {6}
import useSWR, { preload } from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

// You can call the preload function in anywhere
preload('/api/user', fetcher)

function Profile() {
  // The component that actually uses the data:
  const { data, error } = useSWR('/api/user', fetcher)
  // ...
}

export function Page () {
  return <Profile/>
}
```

In this example, the `preload` API is called in the global scope. Which means that we start to preload the resource before React even starts to render anything.
And when the `Profile` component is being rendered, the data can probably be available already. If it‚Äôs still ongoing, the `useSWR` hook will reuse that onging preloading request instead of starting a new one.

The `preload` API can also be used in cases like preloading data for another page that will likely be rendered. More information about prefetching data with SWR can be found [here](/docs/prefetching).

### New Loading State Indicator

`isLoading` is a new state returned by `useSWR`, that indicates **if the request is still ongoing, and there is no data loaded yet**. Previously, the `isValidating` state represents both the initial loading state and revalidating state so we had to check if both `data` and `error` are `undefined` to determine if it‚Äôs the initial loading state.

Now, it is so easy that you can directly use the `isLoading` value to render a loading message:

```jsx
import useSWR from 'swr'

function Profile() {
  const { data, isLoading } = useSWR('/api/user', fetcher)

  if (isLoading) return <div>loading...</div>
  return <div>hello {data.name}!</div>
}
```

Note that `isValidating` is still present so you can still use it to show a loading indicator for revalidations.

<Callout emoji="üìù">
  We have added the new [Understanding SWR](/docs/advanced/understanding) page to describe how SWR returns values, which includes the difference between `isValidating` and `isLoading`, and how to combine them to improve user exeprience.
</Callout>

### ‚ÄúLaggy UI‚Äù

`keepPreviousData` is a new option for keeping the previous fetched data. This improves the UX a lot when you fetch data based on continuous user actions, for example a real-time searching experience. More information can be found [here](/docs/advanced/understanding#return-previous-data-for-better-ux).

```jsx
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  });

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Search..."
      />

      <div className={isLoading ? "loading" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)
      </div>
    </div>
  );
}
```

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Keep previous search results when keepPreviousData has been enabled"
  ratio={640/730}
/>

The code example can be found [here](https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m).

### Extending SWR Configurations

`SWRConfig` can now accept a function for `value` prop that receives the parent config and returns a new config. This empowers user flexibility to configure the SWR config especially in nested `<SWRConfig>` cases. More information can be found [here](/docs/global-configuration).

```jsx
<SWRConfig
  value={parentConfig => ({
    dedupingInterval: parentConfig.dedupingInterval * 5,
    refreshInterval: 100,
  })}
>
  <Page />
</SWRConfig>
```

## Improved React 18 Support

SWR now uses `useSyncExternalStore` and `startTransition` internally to improve the performance and manage states while integrating with React 18, which ensures stronger UI consistency when rendering UI concurrently. This change doesn‚Äôt require any implicity updates on the interface perspective. Developers will benefit from the updates directly.

SWR 2.0 and all the new features are still compatible with React 16 and 17.

## Migration Guide

### Fetcher no longer accepts multiple arguments

`key` is now passed as a single argument.

```diff
- useSWR([1, 2, 3], (a, b, c) => {
+ useSWR([1, 2, 3], ([a, b, c]) => {
  assert(a === 1)
  assert(b === 2)
  assert(c === 3)
})
```

### Multiple Mutations

`mutate` now accepts [a filter function](/blog/swr-v2#mutate-multiple-keys). Previously, the function behaved as returing a key.

```diff
- mutate(() => '/api/item') // a function to return a key
+ mutate(key => typeof key === 'string' && key.startsWith('/api/item?id=')) // a filter function
```

### New Required Property `keys()` for Cache Interface

When you use your own cache implementation, the Cache interface now requires a `keys()` method that returns all keys in the cache object, similar to the JavaScript Map instances.

```diff
interface Cache<Data> {
  get(key: string): Data | undefined
  set(key: string, value: Data): void
  delete(key: string): void
+ keys(): IterableIterator<string>
}
```

### Internal Structure Of The Cached Data

The internal structure of the cache data will be an object that holds all the current states.

```diff
- assert(cache.get(key) === data)
+ assert(cache.get(key) === { data, error, isValidating })

// getter
- cache.get(key)
+ cache.get(key)?.data

// setter
- cache.set(key, data)
+ cache.set(key, { ...cache.get(key), data })
```

<Callout emoji="üö®" type="error">
  You should not write to the cache directly, it might cause undefined behavior.
</Callout>

### SWRConfig.default ‚Üí SWRConfig.defaultValue

`SWRConfig.defaultValue` is the property for accessing the default SWR config.

```diff
- SWRConfig.default
+ SWRConfig.defaultValue
```

### Type InfiniteFetcher is renamed to SWRInfiniteFetcher

```diff
- import type { InfiniteFetcher } from 'swr/infinite'
+ import type { SWRInfiniteFetcher } from 'swr/infinite'
```

### Avoid Using Suspense On The Server-Side

When using `suspense: true` with SWR on the server-side (including pre-rendering in Next.js), it's now required to provide the initial data via [`fallbackData` or `fallback`](/docs/with-nextjs#pre-rendering-with-default-data). This means that you can't use Suspense to fetch data on the server side as of today, but either doing fully client-side data fetching, or fetch the data via the framework (such as getStaticProps in Next.js).

### Changelog

Read the full Changelog [on GitHub](https://github.com/vercel/swr/releases).

## What‚Äôs Next

If you have any feedback about this release, please [let us know](https://github.com/vercel/swr/discussions).

## Thank You!

We also want to thank the entire community, our [142 contributors](https://github.com/vercel/swr/graphs/contributors) (+ [106 docs contributors](https://github.com/vercel/swr-site/graphs/contributors)), and everyone who helped and gave us feedback!
