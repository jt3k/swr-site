---
image: https://swr-card.vercel.app/
description: 'We are excited to announce SWR v2.0 release, with various improvements of DX and new features like preloading, stale, optimistic update and more.'
date:
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

import Authors, { Author } from 'components/authors'
import Video from 'components/video'

# Announcing SWR 2.0

<Authors date="August 27th, 2021">
  <Author name="Shu Ding" link="https://twitter.com/shuding_" />
  <Author name="Jiachi Liu" link="https://twitter.com/huozhi" />
  <Author name="Toru Kobayashi" link="https://twitter.com/koba04" />
  <Author name="Yixuan Xu" link="https://twitter.com/yixuanxu94" />
</Authors>

We are thrilled to introduce the SWR v2.0 release, with a lot of exciting new features and quality-of-life improvements to help you build better applications.

## Better Mutations

### useSWRMutation

`useSWRMutation` is a new SWR hook to make remote mutations easier in a declarative API. Here‚Äôs an overview:

```jsx {11,16}
import useSWRMutation from 'swr/mutation'

async function sendRequest(url, { arg }) {
  return fetch(url, {
    method: 'POST',
    body: JSON.stringify(arg)
  })
}

function App() {
  const { trigger, isMutating } = useSWRMutation('/api/user', sendRequest)

  return (
    <button
      disabled={isMutating}
      onClick={() => trigger({ username: 'johndoe' })}
    >{
      isMutating ? 'Creating...' : 'Create User'
    }</button>
  )
}
```

In the component, it defines a mutation `sendRequest` that affects the resource `'/api/user'`.
Unlike `useSWR`, the mutation function will not be called automatically upon rendering. Instead, it returns a `trigger` function that can be called later to start the mutation manually.

When clicking the button, `sendRequest` will be triggered with the extra argument `{ username: 'johndoe' }`, and `isMutating` will be set to `true` until the mutation is finished.

This new hook also covers other pain points you might have for mutations:

- Show optimistic UI while mutating
- Rollback automatically when mutation fails
- Detect and avoid race conditions between `useSWR`
- Populate the cache of `useSWR` after mutation finishes
- ...

Detailed API references and examples can be found [here](/docs/mutation#useswrmutation) and following sections.

### Optimistic UI for Mutations

`optimisticData` is an option of mutation, which is useful to implement optimistic UI. In v2, you can pass a function as the `optimisticData` option, which accepts current data and returns the new client cache data. More information can be found [here](/docs/mutation#optimistic-updates).

```jsx
mutate('/api/user', updateUserName(newName), {
  optimisticData: user => ({ ...user, name: newName }),
  rollbackOnError: true
});
```

(TODO: show optimistic data + error rollback + cache population + revalidation afterwards with an impressive video)
(maybe https://twitter.com/shuding_/status/1486711438898987015)

### Mutate Multiple Keys

The global `mutate` API now accepts a filter function, where you can mutate or revalidate specific keys. This will be helpful for use cases such as invalidting all the cached data. More information can be found [here](/docs/mutation#mutate-multiple-items).

```jsx
import { mutate } from 'swr'
// Or from the hook if you customized the cache provider:
// { mutate } = useSWRConfig()

mutate(
  key => typeof key === 'string' && key.startsWith('/api/item?id='),
  undefined,
  { revalidate: true }
)
```

## Better User Experience

### SWR DevTools

SWRDevTools is a browser extension for SWR, which helps to debug your SWR cache and the results of your fetcher. Checkout [devtools](/docs/advanced/devtools) section for how to use devtools in your application.

(TODO: We need an image here)

### Preload Data

Sometimes, preloading data can improve the user experience tremendously.
If you know the resource is going to be used later in the application, you can use the new `preload` API to start fetching it early:

```jsx {6}
import useSWR, { preload } from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

// You can call the preload function in anywhere
preload('/api/user', fetcher)

function Profile() {
  // The component that actually uses the data:
  const { data, error } = useSWR('/api/user', fetcher)
  // ...
}

export function Page () {
  return <Profile/>
}
```

In this example, the `preload` API is called in the global scope. Which means that we start to preload the resource before React even starts to render anything.
And when the `Profile` component is being rendered, the data can probably be available already. If it‚Äôs still ongoing, the `useSWR` hook will reuse that onging preloading request instead of starting a new one.

The `preload` API can also be used in cases like preloading data for another page that will likely be rendered. More information about prefetching data with SWR can be found [here](/docs/prefetching).

### New Loading State Indicator

`isLoading` is a new state returned by `useSWR`, that indicates **if the request is still ongoing, and there is no data loaded yet**. Previously, the `isValidating` state represents both the initial loading state and revalidating state so we had to check if both `data` and `error` are `undefined` to determine if it‚Äôs the initial loading state.

Now, it is so easy that you can directly use the `isLoading` value to render a loading message:

```jsx
import useSWR from 'swr'

function Profile() {
  const { data, isLoading } = useSWR('/api/user', fetcher)

  if (isLoading) return <div>loading...</div>
  return <div>hello {data.name}!</div>
}
```

Note that `isValidating` is still present so you can still use it to show a loading indicator for revalidations.

<Callout emoji="üìù">
  We have added the new [Understanding SWR](/docs/advanced/understanding) page to describe how SWR returns values, which includes the difference between `isValidating` and `isLoading`, and how to combine them to improve user exeprience.
</Callout>

### ‚ÄúLaggy UI‚Äù

`keepPreviousData` is a new option for keeping the previous fetched data. This improves the UX a lot when you fetch data based on continuous user actions, for example a real-time searching experience. More information can be found [here](/docs/advanced/understanding#return-previous-data-for-better-ux).

```jsx
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  });

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Search..."
      />

      <div className={isLoading ? "loading" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)
      </div>
    </div>
  );
}
```

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Keep previous search results when keepPreviousData has been enabled"
  ratio={640/730}
/>

The code example can be found [here](https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m).

### Extending SWR Configurations

`SWRConfig` can now accept a function for `value` prop that receives the parent config and returns a new config. This empowers user flexibility to configure the SWR config especially in nested `<SWRConfig>` cases. More information can be found [here](/docs/global-configuration).

```jsx
<SWRConfig
  value={parentConfig => ({
    dedupingInterval: parentConfig.dedupingInterval * 5,
    refreshInterval: 100,
  })}
>
  <Page />
</SWRConfig>
```

## Improved React 18 Support

SWR now uses `useSyncExternalStore` and `startTransition` internally to improve the performance and manage states while integrating with React 18, which ensures stronger UI consistency when rendering UI concurrently. This change doesn‚Äôt require any implicity updates on the interface perspective. Developers will benefit from the updates directly.

SWR 2.0 and all the new features are still compatible with React 16 and 17.

## Migration Guide

### Fetcher no longer accepts multiple arguments

`key` is now passed as a single argument.

```diff
- useSWR([1, 2, 3], (a, b, c) => {
+ useSWR([1, 2, 3], ([a, b, c]) => {
  assert(a === 1)
  assert(b === 2)
  assert(c === 3)
})
```

### Multiple Mutations

`mutate` now accepts [a filter function](/blog/swr-v2#mutate-multiple-keys). Previously, the function behaved as returing a key.

```diff
- mutate(() => '/api/item') // a function to return a key
+ mutate(key => typeof key === 'string' && key.startsWith('/api/item?id=')) // a filter function
```

### New Required Property `keys()` for Cache Interface

When you use your own cache implementation, the Cache interface now requires a `keys()` method that returns all keys in the cache object, similar to the JavaScript Map instances.

```diff
interface Cache<Data> {
  get(key: string): Data | undefined
  set(key: string, value: Data): void
  delete(key: string): void
+ keys(): IterableIterator<string>
}
```

### Internal Structure Of The Cached Data

The internal structure of the cache data will be an object that holds all the current states.

```diff
- assert(cache.get(key) === data)
+ assert(cache.get(key) === { data, error, isValidating })

// getter
- cache.get(key)
+ cache.get(key)?.data

// setter
- cache.set(key, data)
+ cache.set(key, { ...cache.get(key), data })
```

<Callout emoji="üö®" type="error">
  You should not write to the cache directly, it might cause undefined behavior.
</Callout>

### SWRConfig.default ‚Üí SWRConfig.defaultValue

`SWRConfig.defaultValue` is the property for accessing the default SWR config.

```diff
- SWRConfig.default
+ SWRConfig.defaultValue
```

### Type InfiniteFetcher is renamed to SWRInfiniteFetcher

```diff
- import type { InfiniteFetcher } from 'swr/infinite'
+ import type { SWRInfiniteFetcher } from 'swr/infinite'
```

### Avoid Using Suspense On The Server-Side

When using `suspense: true` with SWR on the server-side (including pre-rendering in Next.js), it's now required to provide the initial data via [`fallbackData` or `fallback`](/docs/with-nextjs#pre-rendering-with-default-data). This means that you can't use Suspense to fetch data on the server side as of today, but either doing fully client-side data fetching, or fetch the data via the framework (such as getStaticProps in Next.js).

### Changelog

Read the full Changelog [on GitHub](https://github.com/vercel/swr/releases).

## What‚Äôs Next

If you have any feedback about this release, please [let us know](https://github.com/vercel/swr/discussions).

## Thank You!

We also want to thank the entire community, our [142 contributors](https://github.com/vercel/swr/graphs/contributors) (+ [106 docs contributors](https://github.com/vercel/swr-site/graphs/contributors)), and everyone who helped and gave us feedback!
